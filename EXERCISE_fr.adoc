= Creation de graph UML
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:warning-caption: ‚ö†Ô∏è
:icons: font
:hardbreaks-option:

Pr√©fix√© par ‚úîÔ∏è, des "checkpoints" pour vous aider √† v√©rifier que vous avez tout bon.

== Objectif

Ce projet a pour but de :

* Manipuler les APIs de reflections de Java (`java.lang.reflect`)
* Gagner en connaissance sur les diagrammes de classes UML
* Designer l'API publique d'une _library_ (biblioth√®que)

Nous allons utiliser :

* Le format https://mermaid-js.github.io/mermaid/#/classDiagram[_Mermaid_]
* La biblioth√®que **picocli** pour simplifier le _parsing_ et la validation des arguments de notre programme
* La biblioth√®que **reflections** pour r√©cup√©rer des types r√©pondant √† des crit√®res sp√©cifiques

Le th√®me de ce projet est de construire un outil g√©n√©rant le diagramme de classe (au format _Mermaid_) d'un code Java
non connu √† l'avance.

√Ä tout moment, vous pouvez tester le rendu des graphes avec l'outil : https://mermaid.live

== Notation

La notation se d√©coupera en plusieurs parties :

* Le projet compile
* L'API Java (m√©thodes publiques de la classe `UmlGraph`) se comporte comme d√©crit dans le sujet
* Le programme (m√©thode `Launcher#main`) se comporte comme d√©crit dans le sujet
* L‚Äôhistorique *GIT* lisible et propre
** Pas de message de commit sans _**intention**_
** Pas de commits successifs avec le m√™me message
** (-0.5 point de p√©nalit√© par commit ne respectant pas ces r√®gles)
** Voir cet article pour plus d‚Äôinformation https://chris.beams.io/posts/git-commit/
* Le **Style** doit permettre de lire le code facilement
** Les m√©thodes doivent faire moins de 18 lignes
** Les classes moins de 50 lignes
** Pas de champs mutables (tous les champs doivent √™tre marqu√©s `final`)
** Pas de champ ou m√©thode statique (sauf pour la m√©thode `main`, ou les _factory methods_ dans les `enum` et `record`)
** (-1 point de p√©nalit√© pour les √©carts)
** ‚ö†Ô∏è le code ne doit pas √™tre compact√© / minifi√© (plusieurs expressions ou blocs sur une m√™me ligne)
*** (-4 points de p√©nalit√© dans ce cas)
* L‚Äôint√©gration continue est fonctionnelle
* Les Badges de build et de couverture sont disponibles dans le fichier **README.md**
* La couverture du code est > *85%*

== Pr√©requis

* Git
* Java 21
* Maven 3.9.x
* (Optionnel, mais fortement recommand√©) IntelliJ edition _community_ 2024

'''

* Sur la page du template https://github.com/lernejo/maven-starter-template, cliquer sur "Use this template"
* ‚ö†Ô∏è Renseigner comme nom de d√©p√¥t : *uml_grapher*
* Marquer le futur d√©p√¥t comme *private*
* Une fois le d√©p√¥t cr√©√©, installer l'app https://github.com/apps/korekto[Korekto], ou mettre √† jour sa configuration afin qu'elle ait acc√®s √† ce nouveau d√©p√¥t
* Cloner le d√©p√¥t en utilisant l'*url SSH*
* La branche par d√©faut est la branche `main`, vous √™tes libre de faire des https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request[Pull Requests], mais seule la branche `main` sera corrig√©e.

== Partie 1 - Cr√©er un premier test, puis le code correspondant

Dans cette premi√®re partie, nous allons coder un test avant de coder le code test√©.
C'est l'une des techniques utilis√©es dans le cadre du TDD (**T**est **D**riven **D**evelopment).

.En savoir plus
[%collapsible]
====

[TIP]
=====

Le TDD est une technique de _design_ (et non de test) qui consiste (entre autre) √† √©crire les tests avant le code test√©.

Le but de cette technique est de converger au fur et √† mesure des it√©rations vers la forme la plus simple (utilisable,
car utilis√© par les tests) et n√©cessaire (aucun code mort ou non test√©).

La pratique du TDD consiste en 3 lois que voici :

* On n'√©crit pas de code de production tant qu‚Äôon n‚Äôa pas √©crit un test unitaire qui √©choue (ne pas compiler == √©chec)
* On n'√©crit pas plus d'un seul test unitaire qui √©choue
* On n'√©crit pas plus de code de production que n√©cessaire pour que le test unitaire r√©ussisse

Ainsi le cycle de d√©veloppement it√©ratif est celui-ci :

[source,mermaid]
----
flowchart LR
  id1("Ecriture d'un test<br />(le test √©choue)<br />Phase <b>rouge</b>")-->id2("Ecriture du code de production minimal<br />pour faire passer le test<br />Phase <b>verte</b>")
  id2-->id3("Amelioration du code de production<br />pour le rendre plus lisible / simple<br />Refactoring, Phase <b>bleue</b>")
  id3-->id1
  style id1 fill:#f00,stroke:#333
  style id2 fill:#880,stroke:#333
  style id3 fill:#0bf,stroke:#333
----

=====
====

* Cr√©er un premier test dans le package `fr.lernejo` tel que :

[source,java]
----
class UmlGraphTests {
    @Test
    void empty_interface_with_no_relation() {
        UmlGraph graph = new UmlGraph(Machin.class);

        String output = graph.as(GraphType.Mermaid);

        Assertions.assertThat(output).isEqualTo("""
            classDiagram
            class Machin {
                <<interface>>
            }
            """);
    }

    interface Machin {
    }
}
----

* ‚úîÔ∏è √Ä cette √©tape, le projet ne compile pas, car les classes utilis√©es n'existent pas toutes
* Faire passer ce test, en codant, dans le package `fr.lernejo.umlgrapher` la `class` `UmlGraph` et l'`enum` `GraphType`
* ‚úîÔ∏è A cette √©tape, le projet compile et la commande `mvn test` execute 1 unique test et se termine en succ√®s

== Partie 2 - Utilisation du programme en ligne de commande

Actuellement le code de production du projet est utilisable en tant que biblioth√®que (tout ce qui est public, notamment
classes et m√©thodes).

Dans cette partie, nous allons cr√©er une fonction `main` afin que l'outil puisse √©galement √™tre utilis√© tout seul (de
mani√®re _standalone_).

* Ajouter la d√©pendance vers la biblioth√®que **picocli** dans sa derni√®re version
* ‚ÑπÔ∏è Il est possible de chercher les coordonn√©es de binaires dans le d√©p√¥t Maven central via https://search.maven.org
* :information_source: les coordonn√©es qui nous int√©ressent pour ce projet sont celles de la d√©pendance officielle du projet **picocli**, vous trouverez plus d'info sur le d√©p√¥t GitHub ou dans la documentation officielle
* Cr√©er la classe `fr.lernejo.umlgrapher.Launcher` qui contiendra une m√©thode `main` telle que d√©crite dans la documentation de **picocli**: https://picocli.info/#_example_application
* Modifier `Launcher` de telle sorte que le programme ait deux options :
** `-c` ou `--classes` qui permettra de renseigner **les** classes d'o√π faire partir l'analyse. Cette option doit √™tre _obligatoire_
** `-g` ou `--graph-type` qui permettra de s√©lectionner le type de graph que l'on souhaite en sortie (seulement `GraphType.Mermaid` pour le moment). Cette option aura pour valeur par d√©faut `GraphType.Mermaid`
* Il sera n√©cessaire de modifier le constructeur de `UmlGraph` pour prendre un param√®tre _variadique_ et ainsi pouvoir r√©aliser l'analyse depuis plusieurs classes
* ‚úîÔ∏è V√©rifier que si vous lancer le programme avec les arguments `-c fr.lernejo.UmlGraphTests$Machin` le r√©sultat
est bien le m√™me qu'avec le test unitaire (il sera n√©cessaire de rajouter au classpath le chemin `target/test-classes` pour que la classe `Machin` soit accessible au code de production)

== Partie 3 - Parcourir les types parents

√Ä partir de cette partie, aucune indication pr√©cise sur le design des objets n'est donn√©e.

De m√™me pour les tests, c'est √† vous de cr√©er les tests qui vous semblent pertinents pour les fonctionnalit√©s que vous ajouterez.

Afin de vous simplifier la vie pour les tests, il est recommand√© d'avoir une sortie au format Mermaid _d√©terministe_;  c'est-√†-dire que les diff√©rentes lignes composant la sortie doivent toujours avoir le m√™me ordre.
Dans cette optique, vous pouvez utiliser des structures de donn√©es qui respectent l'ordre et sont triables, telles  que `java.util.List`, ou encore `java.util.TreeSet` qui ordonne les √©l√©ments ajout√©s en fonction d'une fonction de
comparaison donn√©e en param√®tre.

Example pour une structure de donn√©es contenant des objets de type `UmlType` qui triera ses √©l√©ments par `UmlType#name()`, puis par `UmlType#packageName()` :

[source,java]
----
private final Set<UmlType> types = new TreeSet<>(Comparator
    .<UmlType, String>comparing(t->t.name())
    .thenComparing(t->t.packageName()));

    ...
    types.add(type1);
    types.add(type2);
// etc.
----

Afin de respecter les crit√®res de notation, il est conseill√© de s√©parer le code en objets avec des responsabilit√©s bien distinctes (tels que `InternalGraphRepresentation`, `MermaidFormatter`, `UmlRelation` ou encore `UmlType`, mais encore une fois, vous d√©coupez votre code comme vous l'entendez).

Seule l'API publique existante ne doit pas changer, car elle sera appel√©e de mani√®re programmatique par la correction
auto.

Dans cette partie, ajouter la notion de relation aux types parents.

* Une classe peut avoir
** une classe parente (la classe `java.lang.Object` devra √™tre ignor√©e)
** zero, une ou plusieurs interfaces
* Une interface peut h√©riter de zero, une ou plusieurs autres interfaces
* Pour r√©cup√©rer la classe parente, on peut utiliser la m√©thode `myClass.getSuperclass()`
* Pour r√©cup√©rer les interfaces impl√©ment√©es/h√©rit√©es, on peut utiliser la m√©thode `myClass.getInterfaces()`
* Pour savoir si un type est une interface : `Modifier.isInterface(myClass.getModifiers())`
* etc.
* Il est recommand√© de parcourir la hi√©rarchie de type de mani√®re r√©cursive
* Dans le format _Mermaid_,
** La relation d'h√©ritage (classe/classe, interface/interface) est √©crite :

[source,bash]
----
InterfaceParente <|-- InterfaceEnfant : extends
----

* La relation d'impl√©mentation (interface/classe) est √©crite :

[source,bash]
----
InterfaceParente <|.. ClasseEnfant : implements
----

* ‚úîÔ∏è A cette √©tape, cr√©er le graphe pour `Ant`, `Cat` et `Alder` donnera le graphe
suivant :

[source,mermaid]
----
classDiagram
class Alder
class Animal {
    <<interface>>
}
class Ant
class Cat
class Living {
    <<interface>>
}
class Plant {
    <<interface>>
}
class Tree {
    <<interface>>
}
Tree <|.. Alder : implements
Living <|-- Animal : extends
Animal <|.. Ant : implements
Animal <|.. Cat : implements
Living <|-- Plant : extends
Plant <|-- Tree : extends
----

Compte tenu des types suivants :

[source,java]
----
public sealed interface Living {
    sealed interface Animal extends Living {
        final class Ant implements Animal {
        }

        final class Cat implements Animal {
        }
    }

    sealed interface Plant extends Living {
        sealed interface Tree extends Plant {
            final class Alder implements Tree {
            }
        }
    }
}
----

== Partie 4 - Parcourir les types enfants

Dans cette partie, nous allons impl√©menter le parcours des types enfants (en plus de celui des types parents).

Il sera donc n√©cessaire de mettre en place une condition dans le code afin d'√©viter de boucler infiniment entre enfant et parent.

Il n'est pas ais√© de trouver les types enfants en Java, car il faut parcourir l'ensemble des classes disponibles dans le _classpath_ et v√©rifier pour chacune si elles sont le sous-type d'une autre.

Nous allons donc nous servir d'une biblioth√®que tierce qui fera ce travail pour nous.

* Ajouter la d√©pendance √† la biblioth√®que **reflections** (chercher les coordonn√©es exactes dans la doc)
* Voici le code pour cr√©er une instance de l'objet `Reflections` qui scanne toutes les classes, ind√©pendamment du _package_ :

[source,java]
----

Class<?> type = ...;

Reflections reflections = new Reflections(new ConfigurationBuilder()
    .forPackage("")
    .forPackage("", type.getClassLoader())
);
----

* ‚ö†Ô∏è La ligne `.forPackage("", type.getClassLoader())` est importante afin de scanner des classes qui seraient issues d'un autre classloader que celui qui a charg√© votre code (et qui devrait √™tre le `AppClassLoader`)

* Ainsi, pour un type donn√©, on peut requ√™ter l'index cr√©√© par l'objet de type `Reflections` et obtenir les sous-types _directs_ :

[source,java]
----
Class<?> type = Animal.class; // example
Set<Class<?>> subTypes = reflections.get(
    Scanners.SubTypes
        .get(type)
        .asClass(this.getClass().getClassLoader(), type.getClassLoader())
    ); // will contain [Ant.class, Cat.class]
----

* ‚úîÔ∏è A cette √©tape, cr√©er le graphe pour le tableau de param√®tre `Living` devra cr√©er le m√™me graphe que celui propos√© dans la partie pr√©c√©dente


== Partie 5 - Ajouter les m√©thodes et les champs

* Ajouter l'information des m√©thodes et champs existants sur les types
* Pour lister les m√©thodes d'un type : `myType.getDeclaredMethods()`
* Pour lister les champs d'un type : `myType.getDeclaredFields()`
* Pour connaitre la visibilit√© d'une m√©thode : `Modifiers.isPrivate(myMethod.getModifiers()`
* Explorer les m√©thodes disponibles sur les objets de type `Method` et `Field` afin d'extraire les informations n√©cessaires :
** type de retour
** types et noms des param√®tres
** visibilit√©s (private, public, etc.)
** caract√©ristiques (statique, abstract)
* Il sera n√©cessaire d'exclure les m√©thodes et champs _synth√©tiques_ (cf. https://docs.oracle.com/javase/specs/jls/se17/html/jls-13.html[la specification du langage])
* De m√™me pour les `enum` il faudra exclure les m√©thodes `valueOf` et `values`
* Tenez compte de ces informations pour g√©n√©rer le graphe au format Mermaid (cf. la https://mermaid-js.github.io/mermaid/#/classDiagram?id=defining-members-of-a-class[documentation])
* Pour all√©ger la lisibilit√©, ajouter les r√®gles suivantes :
** Les types dont le package commencent par `java.` ne seront pas repr√©sent√©s dans le graphe (mais ils peuvent √™tre utilis√© dans les champs et m√©thodes, cf `int` et `String` dans le graphe ci-dessous)
** S'il y a deux relations ("returns" et "uses") entre deux objets, seules la relation "returns" sera gard√©e
* ‚úîÔ∏è √Ä cette √©tape, cr√©er le graphe pour `Singleton` donnera le graphe suivant :

[source,mermaid]
----
classDiagram
class Singleton {
    -Singleton instance$
    +getInstance()$ Singleton
    +supplySomeStr(int offset) String
}
Singleton <-- Singleton : returns
----

Compte tenu des types suivants :

[source,java]
----
public class Singleton {

    private static final Singleton instance = new Singleton();

    public static Singleton getInstance() {
        return instance;
    }

    public String supplySomeStr(int offset) {
        return String.valueOf(43 + offset);
    }
}
----

* ‚úîÔ∏è De la m√™me fa√ßon, cr√©er le graphe pour `Image` donnera le graphe suivant :

[source,mermaid]
----
classDiagram
class Image {
    <<interface>>
    +display() void
}
class LazyLoadedImage {
    -String fileName
    -RealImage realImage
    +display() void
}
class RealImage {
    -String fileName
    +display() void
    -loadFromDisk(String fileName) void
}
Image <|.. LazyLoadedImage : implements
RealImage <-- LazyLoadedImage : uses
Image <|.. RealImage : implements
----

Compte tenu des types suivants :

[source,java]
----
public sealed interface Image {

    void display();

    final class RealImage implements Image {

        private final String fileName;

        public RealImage(String fileName){
            this.fileName = fileName;
            loadFromDisk(fileName);
        }

        @Override
        public void display() {
            System.out.println("Displaying " + fileName);
        }

        private void loadFromDisk(String fileName){
            System.out.println("Loading " + fileName);
        }
    }

    final class LazyLoadedImage implements Image{

        private RealImage realImage;
        private final String fileName;

        public LazyLoadedImage(String fileName){
            this.fileName = fileName;
        }

        @Override
        public void display() {
            if(realImage == null){
                realImage = new RealImage(fileName);
            }
            realImage.display();
        }
    }
}
----
